<template id="modeling-template">
  <div id="modeling">
    <section id="scrolly">
      <h1 class="intro__hed">
        Modeling
      </h1>
      <p> so much to say here!!</p>

      <figure ref="figure" class="sticky">
        <div id = "flubber-test">
          <svg
            id="transform-svg-test"
            xmlns="http://www.w3.org/2000/svg"
            width="auto"
            height="100%"
          >
            <g id="Path1">
              <path id="river" class="step_1" d="M4.4,166.9.5,166c.8-3,18.3-72.2,59.7-83.5,20.4-5.6,43,4.1,67,28.7l-2.9,2.8c-22.9-23.5-44.1-32.8-63-27.7C22.1,97,4.6,166.2,4.4,166.9Z"/>
              <path id="river" class="step_2" d="M147.9,122.4c-9-18.1-21.7-20.5-35.2-23-9.1-1.7-18.5-3.5-26.4-10.3-6.1-5.3-7.3-13.8-8.9-25.5C76,53.5,74.3,41,69.1,25.3L72.9,24c5.3,16.1,7.1,28.8,8.5,39s2.5,18.8,7.5,23.1c7.1,6.1,15.6,7.7,24.5,9.4,13.9,2.6,28.2,5.3,38.1,25.1Z"/>
              <path id="river" class="step_3" d="M21,219.7l-2.9-2.8C73,161.1,87.8,125.1,99.7,96.2s22.1-53.8,67.2-86.8l2.3,3.2C125,44.9,115.5,68.2,103.4,97.7S76.4,163.3,21,219.7Z"/>
              <!-- path id="river" class="step_1" d="M2.5,166.5s35.4-144,123.2-53.9"/ -->
              <!-- path id="river" class="step_2" d="M71,24.6c11.4,34.5,6.3,54.1,16.6,63,18.9,16.2,46.3,2.3,62.1,33.9"/ -->
              <!-- path id="river" class="step_3" d="M168,11C78.3,76.5,129.4,106.6,19.6,218.3"/ -->
            </g>
            <g id="Path2">
              <path id="river" class="step_1" d="M190.1,153.1c-19.1,0-41.2-13.2-65.8-39.2l2.9-2.7c26.6,28.1,49.8,40.7,69.1,37.3,24.5-4.3,37-33.1,43.8-48.6a74.9,74.9,0,0,1,3.6-7.7l3.4,2c-.8,1.5-2,4.1-3.4,7.3-7,16.2-20.1,46.3-46.7,51A40.2,40.2,0,0,1,190.1,153.1Z"/>
              <path id="river" class="step_2" d="M172.5,242.6l-4-.3c.2-2.5.5-5.3.9-8.3,2.2-19.2,5.5-48.1-6.5-60.8-24.3-25.8-24.3-28.6-15.8-50.4a307.2,307.2,0,0,0,12.4-38.6c2.2-9-3.4-18.1-8.8-26.9s-11.6-19-8.4-28.8,12-15.9,28.4-22.8l1.6,3.7c-15.3,6.4-23.8,13-26.2,20.3s2.6,16.6,8.1,25.5,11.8,19.4,9.2,30a300.4,300.4,0,0,1-12.6,39c-7.8,20.3-8.3,21.5,15,46.2,13.3,14.1,9.8,44.1,7.6,64C173,237.4,172.7,240.3,172.5,242.6Z"/>
              <path id="river" class="step_3" d="M66.9,240.3l-3-2.7c41.6-47.2,53.9-84.2,64.8-116.9,13.8-41.6,24.7-74.4,92.8-104.8l1.7,3.7C156.6,49.2,146.5,79.7,132.5,122,122,153.4,109.1,192.4,66.9,240.3Z"/>
              <!-- path id="river" class="step_1" d="M125.7,112.6c85.8,90.7,111.6-5.5,119.7-19.4"/ -->
              <!-- path id="river" class="step_2" d="M171.5,7.5c-60.6,25.4-3.2,49.8-10.1,77.2-15.4,61.9-31.3,50.8,3,87.1,14.6,15.5,7.7,53.2,6.1,70.7"/ -->
              <!-- path id="river" class="step_3" d="M222.3,17.8c-119.1,53-60.6,111.8-156.9,221.1"/ -->
            </g>
            <g id="Path3">
              <path id="other" class="step_1" d="M78.6,84.4a5.5,5.5,0,1,0,11,0C89,76.9,79,77.5,78.6,84.4Z"/>
              <path id="other" class="step_2" d="M104.9,96.3c.2,7.1,10.4,7.4,10.9,0s-10.5-7-10.9,0"/>
              <path id="other" class="step_3" d="M78.4,37.5c.5.6,2.5,1.3-2.2,1.9S60.5,40.5,60.3,41a14.9,14.9,0,0,1-3.2,6.7c-.3.4,9.9,6.9,9.9,7.3a1.4,1.4,0,0,1-1.6,1.1c-.4,0-10.7-5.9-11.1-5.7A16.2,16.2,0,0,1,46,53.8c-.5,0,.2,10,0,10.5a5.5,5.5,0,0,1-2.3,2.6c-.5,0-1.3-13.1-1.7-13.2a15.8,15.8,0,0,1-7.3-3c-.3-.2-8.4,10.9-8.8,11a2.8,2.8,0,0,1-2.8-.5c-.2-.3,8.5-13.4,8.3-13.7A15.7,15.7,0,0,1,28.3,41c-.1-.6-14.3-1.3-14.3-1.9a4.6,4.6,0,0,1,.8-2.2c.4-.5,13.2-.6,13.2-1.2a17.2,17.2,0,0,1,2.5-7.1c.5-.7-10.1-10.8-9.5-11.5s.7-.9,1.4-1,12.3,8.1,12.7,7.8a14.8,14.8,0,0,1,5.3-2.3c.6-.2-1.8-13.7-1.8-14.3s.5-2.5,1.2-2.5,6.2,16.3,7,16.5a15.8,15.8,0,0,1,7.3,3c.4.3,13.2-12.8,13.6-12.5a3.3,3.3,0,0,1,.5,2.6c-.1.7-10.6,13.4-10.2,14A15.1,15.1,0,0,1,60.5,35C60.7,35.8,77.9,36.8,78.4,37.5Z"/>
            </g>
            <g id="Path4">
              <path id="other" class="step_1" d="M121.7,114.5c.2,7.2,10.4,7.5,10.9,0A5.5,5.5,0,0,0,121.7,114.5Z"/>
              <path id="other" class="step_2" d="M143.4,50.3a5.5,5.5,0,1,0,10.9,0c-.5-7.5-10.5-6.9-10.9,0"/>
              <path id="other" class="step_3" d="M139.9,98.7h-1.2a8,8,0,0,0-14.8,4.1,8,8,0,0,0,8,8H133a8.2,8.2,0,0,0,6.9,3.9,8,8,0,0,0,0-16Z"/>
            </g>
            <g id="Path5">
              <path id="other" class="step_1" d="M165,147c.2,7.1,10.4,7.4,10.9,0S165.4,140,165,147Z"/>
              <path id="other" class="step_2"  d="M168,218.3c.2,7.1,10.5,7.4,11,0s-10.6-6.9-11,0"/>
              <path id="other" class="step_3" d="M139.9,110.5a8.1,8.1,0,0,0-6.9-3.8,7.9,7.9,0,0,0-7.9,8,7.9,7.9,0,0,0,7.9,7.9h1.2a8,8,0,0,0,6.8-7.9A8.5,8.5,0,0,0,139.9,110.5Z"/>
            </g>
          </svg>
        </div>
        <div id="bees-container">
          <div id="progress-container">
          <p class="progress"/>
          </div>
        </div>
      </figure>
      <div id="button-container">
        <h4>Color By</h4>
        <button
          id="clear"
          class="cbutton active"
          @click="recolor('none')"
        >
          Clear
        </button>
        <button
          id="seg_id_nat"
          class="cbutton"
          @click="recolor('seg_id_nat')"
        >
          Segment
        </button>
        <button
          id="year"
          class="cbutton"
          @click="recolor('year')"
        >
          Data Year
        </button>
        <button
          id="month"
          class="cbutton"
          @click="recolor('month')"
        >
          Data Month
        </button>         
      </div>
      <article>
        <div class="step-container">
          <div
            class="step"
            data-step="1"
          >
            <p>Each dot is a monthly RMSE.</p>
          </div>
        </div>
        <div class="step-container">
          <div
            class="step"
            data-step="1"
          >
            <p>RMSE is one way to measure model error/accuracy. RMSE quantifies the distance between predicted and observed values.</p>
          </div>
        </div>
        <div class="step-container">
          <div
            class="step"
            data-step="1"
          >
            <p>Models with RMSE values closer to zero do better at predicting temeprature than models with higher RMSE.</p>
          </div>
        </div>
        <div class="step-container">
          <div
            class="step"
            data-step="2"
          >
            <p>ANN</p>
          </div>
        </div>
        <div class="step-container">
          <div
            class="step"
            data-step="3"
          >
            <p>RNN uses time.</p>
          </div>
        </div>
        <div class="step-container">
          <div
            class="step"
            data-step="4"
          >
            <p>RGCN adds space.</p>
          </div>
        </div>
        <div class="step-container">
          <div
            class="step"
            data-step="5"
          />
          <p>RGCN + pretraining</p>
        </div>
        <div class="step-container">
          <div
            class="step"
            data-step="6"
          />
          <p>and that's how we do it!</p>
        </div>
        <div class="step-container">
          <div
            class="step"
            data-step="7"
          />
          <p />
        </div>
      </article>
    </section>
    <section id="outro">
      <h2>bye</h2>
    </section>
  </div>
</template>

<script>
    import * as d3Base from "d3";
    import { interpolatePath } from 'd3-interpolate-path';
    import * as scrollama from 'scrollama';
    import * as flubber from "flubber";

  export default {
    name: 'Modeling',
    name: 'TransformSVG',
    components: {
    },
    data() {
          return {
            publicPath: process.env.BASE_URL, // this is need for the data files in the public folder, this allows the application to find the files when on different deployment roots
            d3: null, // this is used so that we can assign d3 plugins to the d3 instance
            // global variables instantiated in next section
            margin: 20,
            width: 400,
            height: 300,
            marginX: 20,
            marginY: 20,
            radius: 5,
            force_sim: null,
            bees: null,
            xScale: null,
            scroller: scrollama(), 
            step: 0,
            progress: 0,
            model_sel: null,
            init_decay: null,
            activeButton: null,
            seg_id_nat: null,
            year: null,
            month: null,
            path1_strings: null,
            path2_strings: null,
            path3_strings: null,
            path4_strings: null,
            path5_strings: null,
          }
        },
         watch: {
          activeButton: {
            deep: true,
            handler() {this.recolor(); }
          }
        },
        mounted() {
          this.scroller.setup({
                  step: "#scrolly article .step",
                  debug: false,
                  offset: 0.5,
                  progress: true,
                })
                .onStepEnter(this.handleStepEnter)
                .onStepProgress(this.handleStepProgress)
                .onStepExit(this.handleStepExit);

          // 3. setup resize event...
          this.resize();
          window.addEventListener("resize", this.resize);

          this.d3 = Object.assign(d3Base, { interpolatePath }); // this loads d3 plugins with webpack

          this.paddedRadius = 7;
          
          // define flubber variables - set each d attribute of each path as an element in an array of path strings
          this.path1_strings = Array.from(document.querySelectorAll("#Path1 path")).map(d => d.getAttribute("d"));
          this.path2_strings = Array.from(document.querySelectorAll("#Path2 path")).map(d => d.getAttribute("d"));
          this.path3_strings = Array.from(document.querySelectorAll("#Path3 path")).map(d => d.getAttribute("d"));
          this.path4_strings = Array.from(document.querySelectorAll("#Path4 path")).map(d => d.getAttribute("d"));
          this.path5_strings = Array.from(document.querySelectorAll("#Path5 path")).map(d => d.getAttribute("d"));

          this.getData(); //read in data and then draw chart

        },
        //methods are executed once, not cached as computed properties, rerun everytime deal with new step
        methods: {
          getData() {
            const self = this;

            let promises = [self.d3.csv(self.publicPath + "data/beeswarm_monthly_rmse_cast.csv")];
            Promise.all(promises).then(self.callback);

          },
          callback(data) {
            this.setFlubber();

            let rmse_monthly = data[0];
            
            // calculate value arrays for color coding ONCE here and then we're good forever
            this.seg_id_nat = [...new Set(rmse_monthly.map(item => item.seg_id_nat))];
            this.year = [...new Set(rmse_monthly.map(item => item.year))];
            this.month = [...new Set(rmse_monthly.map(item => item.month))];
            
            var model_list = ['ANN','RNN','RGCN','ANN', 'RNN', 'RGCN', 'RGCN_ptrn','RGCN_ptrn','ANN'];
            var data_set = model_list[this.step];
            this.setChart(rmse_monthly, data_set);

          },
          // resize to keep scroller accurate
          resize () {
            const self = this;
            const bounds = this.$refs.figure.getBoundingClientRect()
            this.width = bounds.width
            this.height = bounds.height
            this.marginX = bounds.width * 0.1
            this.marginY = bounds.height * 0.1
            this.scroller.resize()
          },
          // set up flubber svg
          setFlubber() {
            const self = this;

            // display only the first path element
            self.d3.select("#transform-svg-test")
                .selectAll(".step_2")
                //.filter(function(d, i) {
                //    return i; })
                  .remove();
            self.d3.select("#transform-svg-test")
                .selectAll(".step_3")
                  .remove();
          },
          // animate flubber svg
          animateFlubber() {
            const self = this;

            let animationLength = 2400;

            // PATH 1 //
            // remove the first pathstring from the array and set it as the starting path
            let path1_start = self.path1_strings.shift(),
                // set the first element of the modified array as the ending point
                path1_end = self.path1_strings[0];

            // place the path string you removed at the end of the array                
            self.path1_strings.push(path1_start);

            // transition between the pre-defined starting path and ending path
            self.d3.select("#Path1 path")
              .style("display", "block")
              .datum({ path1_start, path1_end })
              .transition()
              .duration(animationLength)
              .attrTween("d", function(d){
                return flubber.interpolate(d.path1_start, d.path1_end, { maxSegmentLength: 0.5 })
                  //return self.d3.interpolatePath(d.path1_start, d.path1_end)
              })

            // PATH 2 //
            // remove the first pathstring from the array and set it as the starting path
            let path2_start = self.path2_strings.shift(),
                // set the first element of the modified array as the ending point
                path2_end = self.path2_strings[0];

            // place the path string you removed at the end of the array                
            self.path2_strings.push(path2_start);

            // transition between the pre-defined starting path and ending path
            self.d3.select("#Path2 path")
              .style("display", "block")
              .datum({ path2_start, path2_end })
              .transition()
              .duration(animationLength)
              .attrTween("d", function(d){
                  return flubber.interpolate(d.path2_start, d.path2_end, { maxSegmentLength: 0.5 })
                  //return self.d3.interpolatePath(d.path2_start, d.path2_end)
              })

            // PATH 3 //
            // remove the first pathstring from the array and set it as the starting path
            let path3_start = self.path3_strings.shift(),
                // set the first element of the modified array as the ending point
                path3_end = self.path3_strings[0];

            // place the path string you removed at the end of the array                
            self.path3_strings.push(path3_start);

            // transition between the pre-defined starting path and ending path
            self.d3.select("#Path3 path")
              .style("display", "block")
              .datum({ path3_start, path3_end })
              .transition()
              .duration(animationLength)
              .attrTween("d", function(d){
                  return flubber.interpolate(d.path3_start, d.path3_end, { maxSegmentLength: 0.1 })
              })

            // PATH 4 //
            // remove the first pathstring from the array and set it as the starting path
            let path4_start = self.path4_strings.shift(),
                // set the first element of the modified array as the ending point
                path4_end = self.path4_strings[0];

            // place the path string you removed at the end of the array                
            self.path4_strings.push(path4_start);

            // transition between the pre-defined starting path and ending path
            self.d3.select("#Path4 path")
              .style("display", "block")
              .datum({ path4_start, path4_end })
              .transition()
              .duration(animationLength)
              .attrTween("d", function(d){
                  return flubber.interpolate(d.path4_start, d.path4_end, { maxSegmentLength: 0.1 })
              })

            // PATH 5 //
            // remove the first pathstring from the array and set it as the starting path
            let path5_start = self.path5_strings.shift(),
                // set the first element of the modified array as the ending point
                path5_end = self.path5_strings[0];

            // place the path string you removed at the end of the array                
            self.path5_strings.push(path5_start);

            // transition between the pre-defined starting path and ending path
            self.d3.select("#Path5 path")
              .style("display", "block")
              .datum({ path5_start, path5_end })
              .transition()
              .duration(animationLength)
              .attrTween("d", function(d){
                  return flubber.interpolate(d.path5_start, d.path5_end, { maxSegmentLength: 0.1 })
              })
          },
          // draw beeswarm/scatterplot
          setChart(data, model) {
            const self = this;
            
            // Set some forces
            var forceStrength = .3;
            var gravityStrength = 1;
            var friction = 0.6;
            var alpha = .12; // similar to "starting temperature", higher is hotter
            var alphaDecay = 0; // similar to "cool down rate", higher is faster
            var xForceStrength = 2;
            var yForceStrength = .05;
            var timeBeforeKill = 3000;

        // append svg
          this.bees = this.d3.select("#bees-container").append("svg")
            .attr("viewBox", [0, 0, (this.width+this.marginX+this.marginX), (this.height+this.marginY+this.marginY)].join(' '))
            .attr("width", this.width)
            .attr("height", this.height)
            .attr("class", "bees_dotPlot");

          this.bees.append("line", 'svg')
            .classed("main_line", true)
            .attr("x1", this.marginX)
            .attr("y1", this.height/2)
            .attr("x2", this.width-this.marginX)
            .attr("y2", this.height/2)
            .attr("stroke-width", 1.5)
            .attr("stroke", "#A3A0A6");
            
          //scale x axis
          this.xScale = this.d3.scaleLinear()
            .range([this.marginX, this.width - this.marginX])
            .domain([0,7]);

          //draw bees
          //use force to push each dot to x position
          this.bees.selectAll("dot")
            .data(data)
          .enter().append("circle").classed('dot', true)
            .attr("r", this.radius)
            .attr("fill", "orchid")
            .attr("opacity", .8)
            .attr('cx', function(d){return self.xScale(d[model]);})
            .attr('cy', function(d){return this.height/2;})

          //apply force to push dots towards central position on yaxis
          this.force_sim = this.d3.forceSimulation(data)
            .force('x', this.d3.forceX(function(d){
                return self.xScale(d[model])
              }).strength(xForceStrength)
            )
            .force('y', this.d3.forceY(this.height/2).strength(yForceStrength))	
            .force('collide', this.d3.forceCollide(this.paddedRadius).strength(1))
            // .force("charge", d3.forceManyBody().strength(gravityStrength))
            .alpha(alpha)
            .alphaDecay(alphaDecay)
            .velocityDecay(friction)
            .on('tick', self.tick);

            //add decay after set time to smoothly end transition

            this.init_decay = setTimeout(function(){
              console.log('init alpha decay')
              this.force_sim
                .alphaDecay(alphaDecay);
            }, timeBeforeKill);

            // add x axis
            this.bees.append("g")
              .attr("transform", "translate(0," + this.height + ")")
              .attr("stroke-width", "2px")
              .call(this.d3.axisBottom(self.xScale));

          },
          recolor(activeButton){
            const self = this;
            var transitionTime = 1000; // how long it takes for the color to change

            // BUTTON FUNCTIONALITY
            // select the button with class "active"
            var prevButton = this.d3.select(".active");
            // remove active class from all buttons
            this.d3.selectAll('.cbutton').classed('active', false);
            // Find the button just clicked and give it a class "active"
            this.d3.select("#"+activeButton).classed('active', true);

            // MAKE COLOR RAMPS

            var interpolateColors = this.d3.scaleSequential(this.d3.interpolateWarm);

            //interpolate the color scale to have that many stops
            var colorScale = this.d3.scaleOrdinal((this.d3.schemePastel2));  // This is the one currently hooked up, and it's not really working properly right now. 

            // RECOLORING THE CHART
            if(activeButton == "none") {
              this.d3.selectAll(".dot")
                .transition()
                .duration(transitionTime/5)
                .style('fill', "white");
            } else if (activeButton == "seg_id_nat" || "year" || "month") {
              console.log("color me by", activeButton, "and here's the data", this[activeButton]);
              interpolateColors.domain(this[activeButton])
              this.d3.selectAll(".dot")
                .transition()
                .duration(transitionTime/5)
                .style('fill', function(d) { return interpolateColors(d[activeButton])});
            } 

          },

          //update x position on scroll
          updateChart(data) {
            const self = this;
            // list models in order of transitions, use step index to select
            var model_list = ['ANN','RNN','RGCN','ANN', 'RNN', 'RGCN', 'RGCN_ptrn','RNN','ANN'];
            var color_list = ['pink','teal','lightgreen','goldenrod','orangered','cadetblue','orchid','blue','transparent'];
            var color_sel = color_list[data];
            var model_sel = model_list[data];

            this.force_sim.force('x', this.d3.forceX(function(d){
                return self.xScale(d[model_sel])
            }).strength(1))

            this.force_sim
              .alphaDecay(0.01)
              .alpha(0.12)
              .restart()
              .on('tick', self.tick);

            clearTimeout(this.init_decay);

            this.init_decay = setTimeout(function(){
              console.log('re-init alpha decay');
              this.force_sim.alphaDecay(0.1);
            }, 3000)

            this.d3.selectAll(".dot")
              .transition()
                .duration(1000)
                .style('fill', color_sel)

          },
          tick() {
          const self = this;
          this.d3.selectAll(".dot")
            .attr('cx', function(d){return d.x})
            .attr('cy', function(d){return d.y})
        },
        // scrollama event handler functions

        // add class on enter
        handleStepEnter(response) {
          const self = this;
          // response = { element, direction, index }
          console.log(response);
           // changes css for class
          response.element.classList.add("is-active");

          //update number in sticky to show step number
          self.d3.select("#bees-container p")
          .text(response.index + 1);

          this.animateFlubber();

          this.updateChart(response.index);

        },
        
        // add remove class on exit
        handleStepExit(response) {
          const self = this;
          // response = { element, direction, index }
          console.log(response);
          // changes css for class
          response.element.classList.remove("is-active");
        },
        // track scroll progress - not returning anything?
        handleStepProgress(response) {
          //console.log(response.progress);
        }
    }
  }
</script>

<style scoped lang="scss">
#modeling, #modeling-template {
  text-align: center;
}
#progress-container {
  position: relative;
  width:80%;
  height: 30px;
  margin-left:10%;
  line-height: 2em;
}
.progress {
  position: relative;
  background-color:transparent;
  top:1%;
  left:50%;
  font-size: .51em;
  line-height: 1em;
  color: red;
}
#scrolly {
   position: relative;
}

article {
  position: relative;
  margin: 0 auto;
  width: 100%;
}
.sticky {
  position: -webkit-sticky;
  position: sticky;
  top:20vh;
  height: 60vh;
  padding: 1em;
  left: 0;
  margin: 0;
  color: white;
  width: 100vw;
  z-index: 0;
  
}
.sticky h2 {
  text-align: center;
  position: relative;
  top: 40vh;
}

#button-container {
    z-index: 100;
    bottom: 0;
    position: -webkit-sticky;
    position: sticky;
    top: 85vh;
    .cbutton{
        display: inline-block;
        background-color: black;
        color: #DBDAD9;
        padding: 10px;
        margin:0 10px 10px 0;
        border:0.1em solid #DBDAD9;
        border-radius:0.12em;
        box-sizing: border-box;
        text-decoration:none;
        text-align:center;
        transition: all 0.2s;
        min-width: 110px;
        cursor: pointer;
        font-size: .8em;
    }
    .cbutton.active {
      background: #DBDAD9;
      color: #000000;
    }
    .cbutton:focus {
      outline: 0;
    }
    .cbutton:hover {
      color:#000000;
      background-color:#DBDAD9;
    }


  }

.step-container {
  width:100vw;
}
.step {
  position: relative;
  width: 90%;
  margin: 50rem auto 4rem auto;
  color:white;
  z-index: 1;
  height: 50vh;
}

// can trigger attribute changes with .is-active
.step.is-active {
  color: orange;
}

// could add changes by step here
.step.is-active[data-step="1"] {
}
.step.is-active[data-step="2"] {
}
.step.is-active[data-step="3"] {
}
.step.is-active[data-step="4"] {
}
.step.is-active[data-step="7"] {
  margin-bottom: 600px;
}
.step:last-child {
  margin-bottom: 600px;
}


.step p {
  text-align: center;
  padding: 1rem;
  font-size: 2.5rem;
}
#outro {
  text-align: center;
  width: 100%;
  height: 400px;
}
#bees-container {
  position: absolute;
  width: 90%;
  height: 60%;
  left: 5%;
  top: 40%;

}
#flubber-test {
  position: absolute;
  width: 90%;
  height: 40%;
  left: 5%;
  top: 0%;
}
#river{
  stroke: #6399ba;
  fill: #6399ba;
  stroke-width: 2px;
}
#other{
  fill: #EDA550;
  stroke: #EDA550;
  stroke-width: 2px;
}
</style>